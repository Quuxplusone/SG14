/*
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#pragma once

#include <stddef.h>
#include <algorithm>
#include <compare>
#include <cstring>
#include <initializer_list>
#include <memory>
#include <new>
#include <ranges>
#include <type_traits>

#ifndef SG14_INPLACE_VECTOR_ASSERT_PRECONDITION
#include <cassert>
#define SG14_INPLACE_VECTOR_ASSERT_PRECONDITION(x, msg) assert((x) && (msg))
#endif

#ifndef SG14_INPLACE_VECTOR_THROW
#include <stdexcept>
#define SG14_INPLACE_VECTOR_THROW(x) throw (x)
#endif

#ifndef SG14_INPLACE_VECTOR_TRIVIALLY_RELOCATABLE_IF
#if defined(__cpp_impl_trivially_relocatable) && defined(__cpp_lib_trivially_relocatable)
#define SG14_INPLACE_VECTOR_TRIVIALLY_RELOCATABLE_IF(x) [[trivially_relocatable(x)]]
#else
#define SG14_INPLACE_VECTOR_TRIVIALLY_RELOCATABLE_IF(x)
#endif // __cpp_impl_trivially_relocatable
#endif // SG14_INPLACE_VECTOR_TRIVIALLY_RELOCATABLE_IF

namespace sg14::aaipv {

template<class Alloc, class T, class... Us> struct has_trivial_construct : std::true_type {};
template<class Alloc, class T, class... Us> requires requires (Alloc& a, T *p) { a.construct(p, std::declval<Us>()...); }
    struct has_trivial_construct<Alloc, T, Us...> : std::false_type {};
template<class T, class... Us> struct has_trivial_construct<std::pmr::polymorphic_allocator<T>, T, Us...> :
    std::bool_constant<!std::uses_allocator_v<T, std::pmr::polymorphic_allocator<T>>> {};

template<class Alloc, class T> struct has_trivial_destroy : std::true_type {};
template<class Alloc, class T> requires requires (Alloc& a, T *p) { a.destroy(p); }
    struct has_trivial_destroy<Alloc, T> : std::false_type {};
template<class T> struct has_trivial_destroy<std::pmr::polymorphic_allocator<T>, T> : std::true_type {};

template<class Alloc, class = void> struct propagate_on_container_copy_construction : std::true_type {};
template<class Alloc> struct propagate_on_container_copy_construction<Alloc, decltype((std::declval<const Alloc&>().select_on_container_copy_construction(), void()))> : std::allocator_traits<Alloc>::is_always_equal {};

#if defined(__cpp_lib_trivially_relocatable)
template<class T, class Alloc>
struct be_trivially_relocatable : std::bool_constant<
    std::is_trivially_relocatable_v<T> &&
    std::is_trivially_relocatable_v<Alloc> &&
    ((sg14::aaipv::propagate_on_container_copy_construction<Alloc>::value &&
      std::allocator_traits<Alloc>::propagate_on_container_copy_assignment::value &&
      std::allocator_traits<Alloc>::propagate_on_container_move_assignment::value &&
      std::allocator_traits<Alloc>::propagate_on_container_swap::value) ||
     std::allocator_traits<Alloc>::is_always_equal::value) &&
    sg14::aaipv::has_trivial_construct<Alloc, T, const T&>::value &&
    sg14::aaipv::has_trivial_construct<Alloc, T, T&&>::value &&
    sg14::aaipv::has_trivial_destroy<Alloc, T>::value
> {};

template<class T, class Alloc>
struct relocate_in_insert_and_erase : std::bool_constant<
    std::is_trivially_relocatable_v<T> &&
    sg14::aaipv::has_trivial_construct<Alloc, T, const T&>::value &&
    sg14::aaipv::has_trivial_construct<Alloc, T, T&&>::value &&
    sg14::aaipv::has_trivial_destroy<Alloc, T>::value
> {};
#endif // __cpp_lib_trivially_relocatable

template<class It, class Alloc>
void destroy_a(Alloc alloc, It first, It last) {
    using value_type = typename std::allocator_traits<Alloc>::value_type;
    if constexpr (sg14::aaipv::has_trivial_destroy<Alloc, value_type>::value) {
        std::destroy(first, last);
    } else {
        for (; first != last; ++first) {
            std::allocator_traits<Alloc>::destroy(alloc, std::addressof(*first));
        }
    }
}

template<class T, class Alloc>
void uninitialized_value_construct_a(Alloc alloc, T *dfirst, T *dlast) {
    using value_type = typename std::allocator_traits<Alloc>::value_type;
    if constexpr (sg14::aaipv::has_trivial_construct<Alloc, value_type>::value) {
        std::uninitialized_value_construct(dfirst, dlast);
    } else {
        T *orig_dfirst = dfirst;
        while (dfirst != dlast) {
            try {
                std::allocator_traits<Alloc>::construct(alloc, dfirst);
            } catch (...) {
                sg14::aaipv::destroy_a(alloc, orig_dfirst, dfirst);
                throw;
            }
            ++dfirst;
        }
    }
}

template<class T, class Alloc>
void uninitialized_fill_a(Alloc alloc, T *dfirst, T *dlast, const T& value) {
    using value_type = typename std::allocator_traits<Alloc>::value_type;
    if constexpr (sg14::aaipv::has_trivial_construct<Alloc, value_type, const T&>::value) {
        std::uninitialized_fill(dfirst, dlast, value);
    } else {
        T *orig_dfirst = dfirst;
        while (dfirst != dlast) {
            try {
                std::allocator_traits<Alloc>::construct(alloc, dfirst, value);
            } catch (...) {
                sg14::aaipv::destroy_a(alloc, orig_dfirst, dfirst);
                throw;
            }
            ++dfirst;
        }
    }
}

template<class It, class Jt, class Alloc>
void uninitialized_copy_a(Alloc alloc, It first, It last, Jt dfirst) {
    using value_type = typename std::allocator_traits<Alloc>::value_type;
    if constexpr (sg14::aaipv::has_trivial_construct<Alloc, value_type, decltype(*first)>::value) {
        std::uninitialized_copy(first, last, dfirst);
    } else {
        Jt orig_dfirst = dfirst;
        while (first != last) {
            try {
                std::allocator_traits<Alloc>::construct(alloc, std::addressof(*dfirst), *first);
            } catch (...) {
                sg14::aaipv::destroy_a(alloc, orig_dfirst, dfirst);
                throw;
            }
            ++first;
            ++dfirst;
        }
    }
}

template<class It, class Size, class Jt, class Alloc>
void uninitialized_copy_n_a(Alloc alloc, It first, Size n, Jt dfirst) {
    using value_type = typename std::allocator_traits<Alloc>::value_type;
    if constexpr (sg14::aaipv::has_trivial_construct<Alloc, value_type, decltype(*first)>::value) {
        std::uninitialized_copy_n(first, n, dfirst);
    } else {
        Jt orig_dfirst = dfirst;
        while (n) {
            try {
                std::allocator_traits<Alloc>::construct(alloc, std::addressof(*dfirst), *first);
            } catch (...) {
                sg14::aaipv::destroy_a(alloc, orig_dfirst, dfirst);
                throw;
            }
            ++first;
            ++dfirst;
            --n;
        }
    }
}

template<class It, class Size, class Jt, class Alloc>
void ranges_uninitialized_copy_n_a(Alloc alloc, It first, Size n, Jt dfirst, std::unreachable_sentinel_t dlast) {
    using value_type = typename std::allocator_traits<Alloc>::value_type;
    if constexpr (sg14::aaipv::has_trivial_construct<Alloc, value_type, decltype(*first)>::value) {
        std::ranges::uninitialized_copy_n(std::move(first), n, std::move(dfirst), dlast);
    } else {
        sg14::aaipv::uninitialized_copy_n_a(alloc, std::move(first), n, std::move(dfirst));
    }
}

template<class It, class Sent, class Jt, class Sent2, class Alloc>
std::ranges::uninitialized_copy_result<It, Jt>
ranges_uninitialized_copy_a(Alloc alloc, It first, Sent last, Jt dfirst, Sent2 dlast) {
    using value_type = typename std::allocator_traits<Alloc>::value_type;
    if constexpr (sg14::aaipv::has_trivial_construct<Alloc, value_type, decltype(*first)>::value) {
        return std::ranges::uninitialized_copy(std::move(first), std::move(last), std::move(dfirst), std::move(dlast));
    } else {
        auto orig_dfirst = dfirst;
        while (first != last && dfirst != dlast) {
            try {
                std::allocator_traits<Alloc>::construct(alloc, std::addressof(*dfirst), *first);
            } catch (...) {
                sg14::aaipv::destroy_a(alloc, orig_dfirst, dfirst);
                throw;
            }
            ++first;
            ++dfirst;
        }
        return { std::move(first), std::move(dfirst) };
    }
}

template<class It, class Jt, class Alloc>
void uninitialized_move_a(Alloc alloc, It first, It last, Jt dfirst) {
    using value_type = typename std::allocator_traits<Alloc>::value_type;
    if constexpr (sg14::aaipv::has_trivial_construct<Alloc, value_type, decltype(std::move(*first))>::value) {
        std::uninitialized_move(first, last, dfirst);
    } else {
        Jt orig_dfirst = dfirst;
        while (first != last) {
            try {
                std::allocator_traits<Alloc>::construct(alloc, std::addressof(*dfirst), std::move(*first));
            } catch (...) {
                sg14::aaipv::destroy_a(alloc, orig_dfirst, dfirst);
                throw;
            }
            ++first;
            ++dfirst;
        }
    }
}

#if defined(__cpp_lib_trivially_relocatable)
template<class It, class Alloc>
void uninitialized_relocate_a(Alloc alloc, It first, It last, It dfirst) {
    using value_type = typename std::allocator_traits<Alloc>::value_type;
    if constexpr (sg14::aaipv::has_trivial_construct<Alloc, value_type, value_type&&>::value && sg14::aaipv::has_trivial_destroy<Alloc, value_type>::value) {
        std::uninitialized_relocate(first, last, dfirst);
    } else {
        try {
            sg14::aaipv::uninitialized_move_a(alloc, first, last, dfirst);
        } catch (...) {
            sg14::aaipv::destroy_a(alloc, first, last);
            throw;
        }
        sg14::aaipv::destroy_a(alloc, first, last);
    }
}
#endif // __cpp_lib_trivially_relocatable

} // namespace sg14::aaipv

namespace sg14 {

template<class T, bool = (std::is_copy_constructible_v<T> && std::is_copy_assignable_v<T>),
                  bool = (std::is_move_constructible_v<T> && std::is_move_assignable_v<T>)>
struct ipvbase_assignable {
    // Base for copyable types
};
template<class T, bool Copyable>
struct ipvbase_assignable<T, Copyable, false> {
    // Base for immobile types like std::mutex
    explicit ipvbase_assignable() = default;
    ipvbase_assignable(ipvbase_assignable&&) = delete;
    ipvbase_assignable(const ipvbase_assignable&) = delete;
    void operator=(ipvbase_assignable&&) = delete;
    void operator=(const ipvbase_assignable&) = delete;
    ~ipvbase_assignable() = default;
};
template<class T>
struct ipvbase_assignable<T, false, true> {
    explicit ipvbase_assignable() = default;
    ipvbase_assignable(const ipvbase_assignable&) = delete;
    ipvbase_assignable(ipvbase_assignable&&) = default;
    void operator=(const ipvbase_assignable&) = delete;
    ipvbase_assignable& operator=(ipvbase_assignable&&) = default;
    ~ipvbase_assignable() = default;
};

template<class Alloc>
struct ipv_alloc_holder {
#if __has_cpp_attribute(msvc::no_unique_address)
    [[msvc::no_unique_address]] Alloc alloc_;
#else
    [[no_unique_address]] Alloc alloc_;
#endif
    explicit ipv_alloc_holder() = default;
    constexpr explicit ipv_alloc_holder(const Alloc& alloc) : alloc_(alloc) {}
    ipv_alloc_holder(const ipv_alloc_holder&) noexcept = default;
    ipv_alloc_holder(ipv_alloc_holder&&) noexcept = default;
    ipv_alloc_holder& operator=(const ipv_alloc_holder&) noexcept = default;
    ipv_alloc_holder& operator=(ipv_alloc_holder&&) noexcept = default;
    ~ipv_alloc_holder() noexcept = default;
    constexpr const Alloc& get_allocator_() const { return alloc_; }
};

template<class T>
struct ipv_alloc_holder<std::allocator<T>> {
    // libstdc++'s std::allocator is not trivially copyable. Fix that.
    using Alloc = std::allocator<T>;
    explicit ipv_alloc_holder() = default;
    constexpr explicit ipv_alloc_holder(const Alloc&) {}
    static constexpr Alloc get_allocator_() { return Alloc(); }
};

template<class T, size_t N, class size_type>
struct ipv_data_holder {
    size_type size_ = 0;
    union {
        char dummy_;
        T data_[N];
    };
    constexpr void set_size_(size_t n) { size_ = static_cast<size_type>(n); }
    constexpr void swap_sizes_(ipv_data_holder& rhs) { std::swap(size_, rhs.size_); }

    // Our job here is to make the SMFs of `ipv_data_holder` all no-ops, and trivial when possible.
    // Their actual semantics will be taken care of in the `ipvbase` class itself.
    //
    constexpr explicit ipv_data_holder() noexcept {}
    constexpr ipv_data_holder(const ipv_data_holder&) noexcept {}
    constexpr ipv_data_holder(ipv_data_holder&&) noexcept {}
    constexpr void operator=(const ipv_data_holder&) noexcept {}
    constexpr void operator=(ipv_data_holder&&) noexcept {}
    constexpr ~ipv_data_holder() {}

    explicit ipv_data_holder() requires std::is_trivially_constructible_v<T> = default;
    ipv_data_holder(const ipv_data_holder&) requires std::is_trivially_copy_constructible_v<T> = default;
    ipv_data_holder(ipv_data_holder&&) requires std::is_trivially_move_constructible_v<T> = default;
    ipv_data_holder& operator=(const ipv_data_holder&) requires std::is_trivially_copy_assignable_v<T> = default;
    ipv_data_holder& operator=(ipv_data_holder&&) requires std::is_trivially_move_assignable_v<T> = default;
    ~ipv_data_holder() requires std::is_trivially_destructible_v<T> = default;
};

template<class T, class size_type>
struct ipv_data_holder<T, 0, size_type> {
    static constexpr size_type size_ = 0;
    static constexpr T *data_ = nullptr;
    static constexpr void set_size_(size_t) {}
    static constexpr void swap_sizes_(ipv_data_holder&) {}
};

template<class T, size_t N, class Alloc, class = void>
struct SG14_INPLACE_VECTOR_TRIVIALLY_RELOCATABLE_IF((sg14::aaipv::be_trivially_relocatable<T, Alloc>::value))
#if defined(_MSC_VER)
    __declspec(empty_bases)
#endif
    ipvbase : ipv_alloc_holder<Alloc>, ipv_data_holder<T, N, typename std::allocator_traits<Alloc>::size_type>
{
    using size_type = typename std::allocator_traits<Alloc>::size_type;
    using Alloc_ = ipv_alloc_holder<Alloc>;
    using Data_ = ipv_data_holder<T, N, typename std::allocator_traits<Alloc>::size_type>;
    using ipv_data_holder<T, N, typename std::allocator_traits<Alloc>::size_type>::data_;
    using ipv_data_holder<T, N, typename std::allocator_traits<Alloc>::size_type>::size_;
    using ipv_data_holder<T, N, typename std::allocator_traits<Alloc>::size_type>::set_size_;
    using ipv_data_holder<T, N, typename std::allocator_traits<Alloc>::size_type>::swap_sizes_;
    using ipv_alloc_holder<Alloc>::get_allocator_;

    // There is a feature-test macro for "conditionally trivial SMFs," namely
    // (__cpp_concepts >= 202002L); but in fact neither GCC 11.4 nor AppleClang 15
    // set that macro, despite supporting the feature (at least well enough to
    // compile this code). We could check (__cplusplus >= 202002L) instead,
    // except that MSVC doesn't always set *that*! So check nothing, at least for now.
    //
    static_assert(true, "Allocator-aware inplace_vector requires that the compiler support conditionally trivial SMFs");

    static constexpr bool CopyCtorIsDefaultable =
        ((std::is_trivially_copy_constructible_v<T> &&
          sg14::aaipv::has_trivial_construct<Alloc, T, const T&>::value) || (N == 0)) &&
        sg14::aaipv::propagate_on_container_copy_construction<Alloc>::value;

    static constexpr bool MoveCtorIsDefaultable =
        ((std::is_trivially_move_constructible_v<T> &&
          sg14::aaipv::has_trivial_construct<Alloc, T, T&&>::value) || (N == 0));

    static constexpr bool CopyAssignIsDefaultable =
        ((std::is_trivially_copy_constructible_v<T> &&
          std::is_trivially_copy_assignable_v<T> &&
          std::is_trivially_destructible_v<T> &&
          sg14::aaipv::has_trivial_construct<Alloc, T, const T&>::value &&
          sg14::aaipv::has_trivial_destroy<Alloc, T>::value) || (N == 0)) &&
        (std::allocator_traits<Alloc>::propagate_on_container_copy_assignment::value || std::allocator_traits<Alloc>::is_always_equal::value);

    static constexpr bool MoveAssignIsDefaultable =
        ((std::is_trivially_move_constructible_v<T> &&
          std::is_trivially_move_assignable_v<T> &&
          std::is_trivially_destructible_v<T> &&
          sg14::aaipv::has_trivial_construct<Alloc, T, T&&>::value &&
          sg14::aaipv::has_trivial_destroy<Alloc, T>::value) || (N == 0)) &&
        (std::allocator_traits<Alloc>::propagate_on_container_move_assignment::value || std::allocator_traits<Alloc>::is_always_equal::value);

    static constexpr bool DtorIsDefaultable =
        ((std::is_trivially_destructible_v<T> &&
          sg14::aaipv::has_trivial_destroy<Alloc, T>::value) || (N == 0));

    static constexpr bool CopyCtorIsNoexcept =
        ((std::is_nothrow_copy_constructible_v<T> &&
          sg14::aaipv::has_trivial_construct<Alloc, T, const T&>::value) || (N == 0)) &&
        sg14::aaipv::propagate_on_container_copy_construction<Alloc>::value;

    static constexpr bool MoveCtorIsNoexcept =
        ((std::is_nothrow_move_constructible_v<T> &&
          sg14::aaipv::has_trivial_construct<Alloc, T, T&&>::value) || (N == 0));

    // Copy-assignment follows the Lakos Rule: if the precondition might be violated, then it's not noexcept.
    //
    static constexpr bool CopyAssignIsNoexcept =
        ((std::is_nothrow_copy_constructible_v<T> &&
          std::is_nothrow_copy_assignable_v<T> &&
          std::is_nothrow_destructible_v<T> &&
          sg14::aaipv::has_trivial_construct<Alloc, T, const T&>::value &&
          sg14::aaipv::has_trivial_destroy<Alloc, T>::value) || (N == 0)) &&
        (std::allocator_traits<Alloc>::is_always_equal::value || !std::allocator_traits<Alloc>::propagate_on_container_copy_assignment::value);

    // Move-assignment follows the Lakos Rule: if the precondition might be violated, then it's not noexcept.
    //
    static constexpr bool MoveAssignIsNoexcept =
        ((std::is_nothrow_move_constructible_v<T> &&
          std::is_nothrow_move_assignable_v<T> &&
          std::is_nothrow_destructible_v<T> &&
          sg14::aaipv::has_trivial_construct<Alloc, T, T&&>::value &&
          sg14::aaipv::has_trivial_destroy<Alloc, T>::value) || (N == 0)) &&
        (std::allocator_traits<Alloc>::is_always_equal::value || !std::allocator_traits<Alloc>::propagate_on_container_move_assignment::value);

    // Swap follows the Lakos Rule: if the precondition might be violated, then it's not noexcept.
    //
    static constexpr bool SwapIsNoexcept =
        ((std::is_nothrow_swappable_v<T> &&
          std::is_nothrow_move_constructible_v<T> &&
          sg14::aaipv::has_trivial_construct<Alloc, T, T&&>::value &&
          sg14::aaipv::has_trivial_destroy<Alloc, T>::value) || (N == 0)) &&
         (std::allocator_traits<Alloc>::is_always_equal::value || !std::allocator_traits<Alloc>::propagate_on_container_swap::value);

    explicit ipvbase() = default;
    constexpr explicit ipvbase(const Alloc& alloc) : Alloc_(alloc) {}
    constexpr ipvbase(const ipvbase& rhs) noexcept(CopyCtorIsNoexcept)
        : ipvbase(rhs, std::allocator_traits<Alloc>::select_on_container_copy_construction(rhs.get_allocator_()))
    {
    }
    constexpr ipvbase(const ipvbase& rhs, const Alloc& alloc)
        : Alloc_(alloc),
          Data_()  // unneeded, but suppresses a GCC 11.4 warning about "should be explicitly initialized"
    {
        sg14::aaipv::uninitialized_copy_a(get_allocator_(), rhs.data_, rhs.data_ + rhs.size_, data_);
        set_size_(rhs.size_);
    }
    constexpr ipvbase(ipvbase&& rhs) noexcept(MoveCtorIsNoexcept)
        : ipvbase(std::move(rhs), std::move(rhs.get_allocator_()))
    {
    }
    constexpr ipvbase(ipvbase&& rhs, const Alloc& alloc)
        : Alloc_(alloc)
    {
#if defined(__cpp_lib_trivially_relocatable)
        if constexpr (std::is_trivially_relocatable_v<T> &&
                      sg14::aaipv::has_trivial_construct<Alloc, T, T&&>::value &&
                      sg14::aaipv::has_trivial_destroy<Alloc, T>::value) {
            // When the condition is false, this codepath is still correct
            // but it might be a pessimization rather than an optimization.
            //
            sg14::aaipv::uninitialized_relocate_a(get_allocator_(), rhs.data_, rhs.data_ + rhs.size_, data_);
            set_size_(rhs.size_);
            rhs.set_size_(0);
        } else
#endif // __cpp_lib_trivially_relocatable
        {
            sg14::aaipv::uninitialized_move_a(get_allocator_(), rhs.data_, rhs.data_ + rhs.size_, data_);
            set_size_(rhs.size_);
        }
    }
    constexpr void operator=(const ipvbase& rhs) noexcept(CopyAssignIsNoexcept)
    {
        if constexpr (std::allocator_traits<Alloc>::propagate_on_container_copy_assignment::value && !std::allocator_traits<Alloc>::is_always_equal::value) {
            SG14_INPLACE_VECTOR_ASSERT_PRECONDITION(this->get_allocator_() == rhs.get_allocator_(), "operator= tried to propagate an unequal allocator; this is UB");
        }
        if (this == std::addressof(rhs)) {
            // do nothing
        } else if (rhs.size_ <= size_) {
            std::copy(rhs.data_, rhs.data_ + rhs.size_, data_);
            sg14::aaipv::destroy_a(get_allocator_(), data_ + rhs.size_, data_ + size_);
            set_size_(rhs.size_);
        } else {
            std::copy(rhs.data_, rhs.data_ + size_, data_);
            sg14::aaipv::uninitialized_copy_a(get_allocator_(), rhs.data_ + size_, rhs.data_ + rhs.size_, data_ + size_);
            set_size_(rhs.size_);
        }
    }
    constexpr void operator=(ipvbase&& rhs) noexcept(MoveAssignIsNoexcept)
    {
        if constexpr (std::allocator_traits<Alloc>::propagate_on_container_move_assignment::value && !std::allocator_traits<Alloc>::is_always_equal::value) {
            SG14_INPLACE_VECTOR_ASSERT_PRECONDITION(this->get_allocator_() == rhs.get_allocator_(), "operator= tried to propagate an unequal allocator; this is UB");
        }
        if (this == std::addressof(rhs)) {
            // do nothing
        } else if (rhs.size_ <= size_) {
            std::move(rhs.data_, rhs.data_ + rhs.size_, data_);
            sg14::aaipv::destroy_a(get_allocator_(), data_ + rhs.size_, data_ + size_);
            set_size_(rhs.size_);
        } else {
            std::move(rhs.data_, rhs.data_ + size_, data_);
            if constexpr (std::is_trivially_copyable_v<T> &&
                          sg14::aaipv::has_trivial_construct<Alloc, T, T&&>::value &&
                          sg14::aaipv::has_trivial_destroy<Alloc, T>::value) {
                std::uninitialized_move(rhs.data_ + size_, rhs.data_ + rhs.size_, data_ + size_);
                set_size_(rhs.size_);
                return;
            }
#if defined(__cpp_lib_trivially_relocatable)
            if constexpr (std::is_trivially_relocatable_v<T> &&
                          sg14::aaipv::has_trivial_construct<Alloc, T, T&&>::value &&
                          sg14::aaipv::has_trivial_destroy<Alloc, T>::value) {
                std::uninitialized_relocate(rhs.data_ + size_, rhs.data_ + rhs.size_, data_ + size_);
                swap_sizes_(rhs);
                return;
            }
#endif // __cpp_lib_trivially_relocatable
            sg14::aaipv::uninitialized_move_a(get_allocator_(), rhs.data_ + size_, rhs.data_ + rhs.size_, data_ + size_);
            set_size_(rhs.size_);
        }
    }
    constexpr ~ipvbase() {
        sg14::aaipv::destroy_a(get_allocator_(), data_, data_ + size_);
    }

    ipvbase(const ipvbase&) requires CopyCtorIsDefaultable = default;
    ipvbase(ipvbase&&) requires MoveCtorIsDefaultable = default;
    ipvbase& operator=(const ipvbase&) requires CopyAssignIsDefaultable = default;
    ipvbase& operator=(ipvbase&&) requires MoveAssignIsDefaultable = default;
    ~ipvbase() requires DtorIsDefaultable = default;

    static constexpr void swap_(ipvbase& a, ipvbase& b) noexcept(SwapIsNoexcept)
    {
        if constexpr (std::allocator_traits<Alloc>::propagate_on_container_swap::value && !std::allocator_traits<Alloc>::is_always_equal::value) {
            SG14_INPLACE_VECTOR_ASSERT_PRECONDITION(a.get_allocator_() == b.get_allocator_(), "swap tried to swap unequal allocators; this is UB");
        }
        if (a.size_ < b.size_) {
            swap_(b, a);
        } else {
            std::swap_ranges(a.data_, a.data_ + b.size_, b.data_);
#if defined(__cpp_lib_trivially_relocatable)
            size_t n = a.size_;
            a.set_size_(b.size_);
            sg14::aaipv::uninitialized_relocate_a(get_allocator_(), a.data_ + b.size_, a.data_ + n, b.data_ + b.size_);
            b.set_size_(n);
#else
            sg14::aaipv::uninitialized_move_a(get_allocator_(), a.data_ + b.size_, a.data_ + a.size_, b.data_ + b.size_);
            sg14::aaipv::destroy_a(get_allocator_(), a.data_ + b.size_, a.data_ + a.size_);
            a.swap_sizes_(b);
#endif
        }
    }
};

template<class T, size_t N, class Alloc = std::allocator<T>>
class inplace_vector : ipvbase_assignable<T>, ipvbase<T, N, Alloc> {
    using ipvbase_t = ipvbase<T, N, Alloc>;
    using ipvbase_t::data_;
    using ipvbase_t::size_;
    using ipvbase_t::set_size_;
    using ipvbase_t::swap_sizes_;
    using ipvbase_t::get_allocator_;
public:
    static_assert(std::is_same_v<T, typename std::allocator_traits<Alloc>::value_type>);

    using value_type = T;
    using allocator_type = Alloc;
    using pointer = typename std::allocator_traits<Alloc>::pointer;
    using const_pointer = typename std::allocator_traits<Alloc>::const_pointer;
    using reference = T&;
    using const_reference = const T&;
    using size_type = typename std::allocator_traits<Alloc>::size_type;
    using difference_type = typename std::allocator_traits<Alloc>::difference_type;
    using iterator = pointer;
    using const_iterator = const_pointer;
    using reverse_iterator = std::reverse_iterator<iterator>;
    using const_reverse_iterator = std::reverse_iterator<const_iterator>;

    // [inplace.vector.cons]

    inplace_vector() = default;
    inplace_vector(inplace_vector&&) = default;
    inplace_vector(const inplace_vector&) = default;
    inplace_vector& operator=(inplace_vector&&) = default;
    inplace_vector& operator=(const inplace_vector&) = default;
    inplace_vector& operator=(std::initializer_list<value_type> il) { assign(il.begin(), il.end()); return *this; }

    constexpr inplace_vector(std::initializer_list<value_type> il) : inplace_vector(il.begin(), il.end()) {}
    constexpr explicit inplace_vector(size_type n) {
        if (n > N) {
            SG14_INPLACE_VECTOR_THROW(std::bad_alloc());
        }
        sg14::aaipv::uninitialized_value_construct_a(get_allocator(), data_, data_ + n);
        set_size_(n);
    }
    constexpr inplace_vector(size_type n, const value_type& value) { assign(n, value); }

    template<class It, std::enable_if_t<std::is_base_of_v<std::input_iterator_tag, typename std::iterator_traits<It>::iterator_category>, int> = 0>
    constexpr inplace_vector(It first, It last) {
        if constexpr (std::is_base_of_v<std::random_access_iterator_tag, typename std::iterator_traits<It>::iterator_category>) {
            size_t n = last - first;
            if (n > N) {
                SG14_INPLACE_VECTOR_THROW(std::bad_alloc());
            }
            sg14::aaipv::uninitialized_copy_n_a(get_allocator(), first, n, data_);
            set_size_(n);
        } else {
            for (; first != last; ++first) {
                emplace_back(*first);
            }
        }
    }

    // [inplace.vector.cons.alloc]

    explicit inplace_vector(const allocator_type& alloc) : ipvbase_t(alloc) {}
    inplace_vector(inplace_vector&& rhs, const allocator_type& alloc) : ipvbase_t(std::move(rhs), alloc) {}
    inplace_vector(const inplace_vector& rhs, const allocator_type& alloc) : ipvbase_t(rhs, alloc) {}
    constexpr inplace_vector(std::initializer_list<value_type> il, const allocator_type& alloc) : inplace_vector(il.begin(), il.end(), alloc) {}
    constexpr inplace_vector(size_type n, const allocator_type& alloc) : ipvbase_t(alloc) {
        if (n > N) {
            SG14_INPLACE_VECTOR_THROW(std::bad_alloc());
        }
        sg14::aaipv::uninitialized_value_construct_a(get_allocator(), data_, data_ + n);
        set_size_(n);
    }
    constexpr inplace_vector(size_type n, const value_type& value, const allocator_type& alloc) : ipvbase_t(alloc) { assign(n, value); }

    template<class It, std::enable_if_t<std::is_base_of_v<std::input_iterator_tag, typename std::iterator_traits<It>::iterator_category>, int> = 0>
    constexpr inplace_vector(It first, It last, const allocator_type& alloc) : ipvbase_t(alloc) {
        if constexpr (std::is_base_of_v<std::random_access_iterator_tag, typename std::iterator_traits<It>::iterator_category>) {
            size_t n = last - first;
            if (n > N) {
                SG14_INPLACE_VECTOR_THROW(std::bad_alloc());
            }
            sg14::aaipv::uninitialized_copy_n_a(get_allocator(), first, n, data_);
            set_size_(n);
        } else {
            for (; first != last; ++first) {
                emplace_back(*first);
            }
        }
    }

    constexpr void assign(std::initializer_list<value_type> il) { assign(il.begin(), il.end()); }

    constexpr void assign(size_type n, const value_type& value) {
        if (n <= size_) {
            for (size_t i = 0; i < n; ++i) {
                data_[i] = value;
            }
            sg14::aaipv::destroy_a(get_allocator(), data_ + n, data_ + size_);
            set_size_(n);
        } else if (n > N) {
            SG14_INPLACE_VECTOR_THROW(std::bad_alloc());
        } else {
            size_t m = size_;
            for (size_t i = 0; i < m; ++i) {
                data_[i] = value;
            }
            for (size_t i = m; i < n; ++i) {
                unchecked_emplace_back(value);
            }
        }
    }

    template<class It, std::enable_if_t<std::is_base_of_v<std::input_iterator_tag, typename std::iterator_traits<It>::iterator_category>, int> = 0>
    constexpr void assign(It first, It last) {
        size_t n = size_;
        for (size_t i = 0; i < n; ++i) {
            if (first == last) {
                sg14::aaipv::destroy_a(get_allocator(), data_ + i, data_ + n);
                set_size_(i);
                return;
            }
            data_[i] = *first;
            ++first;
        }
        for (; first != last; ++first) {
            emplace_back(*first);
        }
    }

#if __cpp_lib_ranges >= 201911L && __cpp_lib_ranges_to_container >= 202202L
    template<std::ranges::input_range R>
        requires std::convertible_to<std::ranges::range_reference_t<R>, value_type>
    constexpr inplace_vector(std::from_range_t, R&& rg) {
        if constexpr (std::ranges::sized_range<R>) {
            size_t n = std::ranges::size(rg);
            if (n > N) {
                SG14_INPLACE_VECTOR_THROW(std::bad_alloc());
            }
            sg14::aaipv::ranges_uninitialized_copy_n_a(get_allocator(), std::ranges::begin(rg), n, data_, std::unreachable_sentinel);
            set_size_(n);
        } else {
            for (auto&& e : rg) {
                emplace_back(decltype(e)(e));
            }
        }
    }

    template<std::ranges::input_range R>
        requires std::convertible_to<std::ranges::range_reference_t<R>, value_type>
    constexpr inplace_vector(std::from_range_t, R&& rg, const allocator_type& alloc) : ipvbase_t(alloc) {
        for (auto&& e : rg) {
            emplace_back(decltype(e)(e));
        }
    }

    template<std::ranges::input_range R>
        requires std::convertible_to<std::ranges::range_reference_t<R>, value_type>
    constexpr void assign_range(R&& rg) {
        auto first = std::ranges::begin(rg);
        auto last = std::ranges::end(rg);
        size_t n = size_;
        for (size_t i = 0; i < n; ++i) {
            if (first == last) {
                sg14::aaipv::destroy_a(get_allocator(), data_ + i, data_ + n);
                set_size_(i);
                return;
            }
            data_[i] = *first;
            ++first;
        }
        for (; first != last; ++first) {
            emplace_back(*first);
        }
    }
#endif // __cpp_lib_ranges >= 201911L && __cpp_lib_ranges_to_container >= 202202L

    constexpr allocator_type get_allocator() const noexcept { return get_allocator_(); }

    // iterators

    constexpr iterator begin() noexcept { return data_; }
    constexpr iterator end() noexcept { return data_ + size_; }
    constexpr const_iterator begin() const noexcept { return data_; }
    constexpr const_iterator end() const noexcept { return data_ + size_; }
    constexpr reverse_iterator rbegin() noexcept { return reverse_iterator(end()); }
    constexpr reverse_iterator rend() noexcept { return reverse_iterator(begin()); }
    constexpr const_reverse_iterator rbegin() const noexcept { return const_reverse_iterator(end()); }
    constexpr const_reverse_iterator rend() const noexcept { return const_reverse_iterator(begin()); }
    constexpr const_iterator cbegin() const noexcept { return data_; }
    constexpr const_iterator cend() const noexcept { return data_ + size_; }
    constexpr const_reverse_iterator crbegin() const noexcept { return const_reverse_iterator(end()); }
    constexpr const_reverse_iterator crend() const noexcept { return const_reverse_iterator(begin()); }

    constexpr void resize(size_type n) {
        if (n < size_) {
            sg14::aaipv::destroy_a(get_allocator(), data_ + n, data_ + size_);
            set_size_(n);
        } else if (n > N) {
            SG14_INPLACE_VECTOR_THROW(std::bad_alloc());
        } else {
            for (size_t i = n - size_; i != 0; --i) {
                unchecked_emplace_back();
            }
        }
    }

    constexpr void resize(size_type n, const value_type& value) {
        if (n < size_) {
            sg14::aaipv::destroy_a(get_allocator(), data_ + n, data_ + size_);
            set_size_(n);
        } else if (n > N) {
            SG14_INPLACE_VECTOR_THROW(std::bad_alloc());
        } else {
            for (size_t i = n - size_; i != 0; --i) {
                unchecked_emplace_back(value);
            }
        }
    }

    static constexpr void reserve(size_type n) { if (n > N) SG14_INPLACE_VECTOR_THROW(std::bad_alloc()); }
    static constexpr void shrink_to_fit() noexcept {}

    // element access

    constexpr reference operator[](size_type i) { return data_[i]; }
    constexpr reference front() { return data_[0]; }
    constexpr reference back() { return data_[size_ - 1]; }

    constexpr const_reference operator[](size_type i) const { return data_[i]; }
    constexpr const_reference front() const { return data_[0]; }
    constexpr const_reference back() const { return data_[size_ - 1]; }

    constexpr reference at(size_type i) {
        if (i >= size_) {
            SG14_INPLACE_VECTOR_THROW(std::out_of_range("inplace_vector::at"));
        }
        return data_[i];
    }
    constexpr const_reference at(size_type i) const {
        if (i >= size_) {
            SG14_INPLACE_VECTOR_THROW(std::out_of_range("inplace_vector::at"));
        }
        return data_[i];
    }

    // [inplace.vector.data]

    constexpr T* data() noexcept { return data_; }
    constexpr const T* data() const noexcept { return data_; }
    constexpr size_type size() const noexcept { return size_; }
    static constexpr size_type max_size() noexcept { return N; }
    static constexpr size_type capacity() noexcept { return N; }
    [[nodiscard]] constexpr bool empty() const noexcept { return size_ == 0; };

    // [inplace.vector.modifiers]

    template<class... Args>
    value_type& unchecked_emplace_back(Args&&... args) {
        // Precondition: (size_ < N)
        value_type *p = data_ + size_;
        allocator_type alloc = get_allocator();
        std::allocator_traits<allocator_type>::construct(alloc, p, static_cast<Args&&>(args)...);
        set_size_(size_ + 1);
        return *p;
    }
    value_type& unchecked_push_back(const value_type& value) { return unchecked_emplace_back(value); }
    value_type& unchecked_push_back(value_type&& value) { return unchecked_emplace_back(static_cast<value_type&&>(value)); }

    template<class... Args>
    constexpr value_type *try_emplace_back(Args&&... args) {
        if (size_ == N) {
            return nullptr;
        }
        return std::addressof(unchecked_emplace_back(static_cast<Args&&>(args)...));
    }
    constexpr value_type *try_push_back(const value_type& value) { return try_emplace_back(value); }
    constexpr value_type *try_push_back(value_type&& value) { return try_emplace_back(static_cast<value_type&&>(value)); }

    template<class... Args>
    value_type& emplace_back(Args&&... args) {
        if (size_ == N) {
            SG14_INPLACE_VECTOR_THROW(std::bad_alloc());
        }
        return unchecked_emplace_back(static_cast<Args&&>(args)...);
    }
    value_type& push_back(const value_type& value) { return emplace_back(value); }
    value_type& push_back(value_type&& value) { return emplace_back(static_cast<value_type&&>(value)); }

#if __cpp_lib_ranges >= 201911L && __cpp_lib_ranges_to_container >= 202202L
    template<std::ranges::input_range R>
        requires std::convertible_to<std::ranges::range_reference_t<R>, value_type>
    constexpr void append_range(R&& rg) {
        for (auto&& e : rg) {
            emplace_back(static_cast<decltype(e)>(e));
        }
    }
#endif // __cpp_lib_ranges >= 201911L && __cpp_lib_ranges_to_container >= 202202L

    void pop_back() {
        std::destroy_at(data_ + size_ - 1);
        set_size_(size_ - 1);
    }

    template<class... Args>
    iterator emplace(const_iterator pos, Args&&... args) {
        T *it = const_cast<T*>(std::to_address(pos));
        emplace_back(static_cast<Args&&>(args)...);
        std::rotate(it, data_ + size_ - 1, data_ + size_);
        return std::pointer_traits<pointer>::pointer_to(*it);
    }
    iterator insert(const_iterator pos, const value_type& value) { return emplace(pos, value); }
    iterator insert(const_iterator pos, value_type&& value) { return emplace(pos, static_cast<value_type&&>(value)); }

    iterator insert(const_iterator pos, size_type n, const value_type& value) {
        if (N - size_ < n) {
            SG14_INPLACE_VECTOR_THROW(std::bad_alloc());
        }
        T *it = const_cast<T*>(std::to_address(pos));
        T *oldend = data_ + size_;
#if defined(__cpp_lib_trivially_relocatable)
        // Open a window and fill in-place; if filling fails, close the window again.
        if constexpr (sg14::aaipv::relocate_in_insert_and_erase<T, Alloc>::value) {
            std::uninitialized_relocate_backward(it, oldend, oldend + n);
            try {
                std::uninitialized_fill_n(it, n, value);
                set_size_(size_ + n);
            } catch (...) {
                std::uninitialized_relocate(it + n, oldend + n, it);
                throw;
            }
            return std::pointer_traits<pointer>::pointer_to(*it);
        }
#endif
        // Fill at the end of the vector, then rotate into place.
        sg14::aaipv::uninitialized_fill_a(oldend, oldend + n, value);
        set_size_(size_ + n);
        std::rotate(it, oldend, oldend + n);
        return std::pointer_traits<pointer>::pointer_to(*it);
    }

    template<class It, std::enable_if_t<std::is_base_of_v<std::input_iterator_tag, typename std::iterator_traits<It>::iterator_category>, int> = 0>
    iterator insert(const_iterator pos, It first, It last) {
        T *it = const_cast<T*>(std::to_address(pos));
        T *oldend = data_ + size_;
        if constexpr (std::is_base_of_v<std::random_access_iterator_tag, typename std::iterator_traits<It>::iterator_category>) {
            size_t n = (last - first);
            if (N - size_ < n) {
                SG14_INPLACE_VECTOR_THROW(std::bad_alloc());
            }
#if defined(__cpp_lib_trivially_relocatable)
            // Open a window and fill in-place; if filling fails, close the window again.
            if constexpr (sg14::aaipv::relocate_in_insert_and_erase<T, Alloc>::value) {
                std::uninitialized_relocate_backward(it, oldend, oldend + n);
                try {
                    std::uninitialized_copy_n(first, n, it);
                    set_size_(size_ + n);
                } catch (...) {
                    std::uninitialized_relocate(it + n, oldend + n, it);
                    throw;
                }
                return std::pointer_traits<pointer>::pointer_to(*it);
            }
#endif
            // Fill at the end of the vector, then rotate into place.
            sg14::aaipv::uninitialized_copy_n_a(get_allocator(), first, n, oldend);
            set_size_(size_ + n);
            std::rotate(it, oldend, oldend + n);
        } else {
            auto oldend = end();
            for (; first != last; ++first) {
                emplace_back(*first);
            }
            std::rotate(it, oldend, end());
        }
        return std::pointer_traits<pointer>::pointer_to(*it);
    }

#if __cpp_lib_ranges >= 201911L && __cpp_lib_ranges_to_container >= 202202L
    template<std::ranges::input_range R>
        requires std::convertible_to<std::ranges::range_reference_t<R>, value_type>
    iterator insert_range(const_iterator pos, R&& rg) {
        T *it = const_cast<T*>(std::to_address(pos));
        T *oldend = data_ + size_;
        if constexpr (std::ranges::sized_range<R>) {
            size_t n = std::ranges::size(rg);
            if (N - size_ < n) {
                SG14_INPLACE_VECTOR_THROW(std::bad_alloc());
            }
#if defined(__cpp_lib_trivially_relocatable)
            // Open a window and fill in-place; if filling fails, close the window again.
            if constexpr (sg14::aaipv::relocate_in_insert_and_erase<T, Alloc>::value) {
                std::uninitialized_relocate_backward(it, oldend, oldend + n);
                try {
                    std::ranges::uninitialized_copy_n(std::ranges::begin(rg), n, it, std::unreachable_sentinel);
                    set_size_(size_ + n);
                } catch (...) {
                    std::uninitialized_relocate(it + n, oldend + n, it);
                    throw;
                }
                return std::pointer_traits<pointer>::pointer_to(*it);
            }
#endif
            // Fill at the end of the vector, then rotate into place.
            sg14::aaipv::ranges_uninitialized_copy_n_a(get_allocator(), std::ranges::begin(rg), n, oldend, std::unreachable_sentinel);
            set_size_(size_ + n);
            std::rotate(it, oldend, oldend + n);
        } else {
            auto last = std::ranges::end(rg);
            auto [rgend, newend] = sg14::aaipv::ranges_uninitialized_copy_a(get_allocator(), std::ranges::begin(rg), last, oldend, data_ + N);
            if (rgend != last) {
                sg14::aaipv::destroy_a(get_allocator(), oldend, newend);
                SG14_INPLACE_VECTOR_THROW(std::bad_alloc());
            } else {
                set_size_(newend - data_);
                std::rotate(it, oldend, newend);
            }
        }
        return std::pointer_traits<pointer>::pointer_to(*it);
    }
#endif // __cpp_lib_ranges >= 201911L && __cpp_lib_ranges_to_container >= 202202L

    iterator insert(const_iterator pos, std::initializer_list<value_type> il) { return insert(pos, il.begin(), il.end()); }

    iterator erase(const_iterator pos) { return erase(pos, pos + 1); }

    iterator erase(const_iterator first, const_iterator last) {
        T *ifirst = const_cast<T*>(std::to_address(first));
        T *ilast = const_cast<T*>(std::to_address(last));
        auto n = ilast - ifirst;
        if (n != 0) {
            T *oldend = data_ + size_;
#if defined(__cpp_lib_trivially_relocatable)
            if constexpr (sg14::aaipv::relocate_in_insert_and_erase<T, Alloc>::value) {
                std::destroy(ifirst, ilast);
                std::uninitialized_relocate(ilast, oldend, ifirst);
                set_size_(size_ - n);
                return std::pointer_traits<pointer>::pointer_to(*ifirst);
            }
#endif // __cpp_lib_trivially_relocatable
            sg14::aaipv::destroy_a(get_allocator(), std::move(ilast, oldend, ifirst), oldend);
            set_size_(size_ - n);
        }
        return std::pointer_traits<pointer>::pointer_to(*ifirst);
    }

    constexpr void clear() noexcept {
        sg14::aaipv::destroy_a(get_allocator(), data_, data_ + size_);
        set_size_(0);
    }

    constexpr void swap(inplace_vector& b) noexcept(noexcept(ipvbase_t::swap_(*this, b))) {
        ipvbase_t::swap_(*this, b);
    }

    friend constexpr void swap(inplace_vector& a, inplace_vector& b) noexcept(noexcept(a.swap(b))) {
        a.swap(b);
    }

    constexpr friend bool operator==(const inplace_vector& a, const inplace_vector& b) {
        if (a.size_ != b.size_) {
            return false;
        }
        const T *adata = a.data_;
        const T *bdata = b.data_;
        for (size_t i = 0; i < a.size_; ++i) {
            if (adata[i] != bdata[i]) {
                return false;
            }
        }
        return true;
    }

    constexpr friend auto operator<=>(const inplace_vector& a, const inplace_vector& b) {
        const T *adata = a.data_;
        const T *bdata = b.data_;
        size_t n = (a.size_ < b.size_) ? a.size_ : b.size_;
        for (size_t i = 0; i < n; ++i) {
            if (auto r = adata[i] <=> bdata[i]; r != 0) {
                return r;
            }
        }
        return (a.size_ <=> b.size_);
    }
};

} // namespace sg14

#if __has_include(<memory_resource>)
#include <memory_resource>
namespace sg14::pmr {

template<class T, size_t N>
using inplace_vector = sg14::inplace_vector<T, N, std::pmr::polymorphic_allocator<T>>;

} // namespace sg14::pmr
#endif
