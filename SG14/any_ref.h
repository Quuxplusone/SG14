/*
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#pragma once

#include <functional>
#include <typeinfo>
#include <type_traits>
#include <utility>

#if __cplusplus >= 201703L
#include <any>  // for bad_any_cast
namespace stdext {
    using std::bad_any_cast;
} // namespace stdext
#else
namespace stdext {
    class bad_any_cast : public std::bad_cast {};
} // namespace stdext
#endif

namespace stdext {

class any_cref;

class any_ref {
public:
    constexpr any_ref() noexcept :
        id_ptr_{&typeid(void)}, closure_ptr_{}
    {}

    template<class T, class = typename std::enable_if<!std::is_const<T>::value>::type>
    constexpr any_ref(std::reference_wrapper<T> closure) noexcept :
        id_ptr_{&typeid(T)},
        closure_ptr_{(void*)std::addressof(closure.get())}
    {}

    any_ref(const any_ref&) = default;
    any_ref(any_ref&&) = default;
    any_ref& operator= (const any_ref&) = default;
    any_ref& operator= (any_ref&&) = default;
    ~any_ref() = default;

    constexpr bool has_value() const noexcept { return id_ptr_ != &typeid(void); }
    constexpr const std::type_info& type() const noexcept { return *id_ptr_; }

#if __cplusplus >= 201402L
    constexpr
#endif
    void swap(any_ref& other) noexcept {
        if (this == std::addressof(other)) return;
        std::swap(this->id_ptr_, other.id_ptr_);
        std::swap(this->closure_ptr_, other.closure_ptr_);
    }

private:
    template<class T> friend T *any_cast(const any_ref *) noexcept;
    friend class any_cref;

    const std::type_info *id_ptr_;
    void *closure_ptr_;
};

class any_cref {
public:
    constexpr any_cref() noexcept :
        id_ptr_{&typeid(void)}, closure_ptr_{}
    {}

    template<class T>
    constexpr any_cref(std::reference_wrapper<T> closure) noexcept :
        id_ptr_{&typeid(T)},
        closure_ptr_{static_cast<const void*>(std::addressof(closure.get()))}
    {}

    constexpr any_cref(const any_ref& a) noexcept :
        id_ptr_{a.id_ptr_},
        closure_ptr_{const_cast<const void*>(a.closure_ptr_)}
    {}

    any_cref(const any_cref&) = default;
    any_cref(any_cref&&) = default;
    any_cref& operator= (const any_cref&) = default;
    any_cref& operator= (any_cref&&) = default;
    ~any_cref() = default;

    constexpr bool has_value() const noexcept { return id_ptr_ != &typeid(void); }
    constexpr const std::type_info& type() const noexcept { return *id_ptr_; }

#if __cplusplus >= 201402L
    constexpr
#endif
    void swap(any_cref& other) noexcept {
        if (this == std::addressof(other)) return;
        std::swap(this->id_ptr_, other.id_ptr_);
        std::swap(this->closure_ptr_, other.closure_ptr_);
    }

private:
    template<class T> friend const T *any_cast(const any_cref *) noexcept;

    const std::type_info *id_ptr_;
    const void *closure_ptr_;
};

template<class T> T *any_cast(const any_ref *a) noexcept {
    return (a != nullptr && a->type() == typeid(T)) ? (T *)a->closure_ptr_ : nullptr;
}

template<class T> T any_cast(const any_ref& a) {
    using U = typename std::remove_cv<typename std::remove_reference<T>::type>::type;
    static_assert(std::is_constructible<T, U&>::value, "");
    U *p = any_cast<U>(&a);
    return p ? static_cast<T>(*p) : throw bad_any_cast();
}

template<class T> const T *any_cast(const any_cref *a) noexcept {
    return (a != nullptr && a->type() == typeid(T)) ? (const T *)a->closure_ptr_ : nullptr;
}

template<class T> T any_cast(const any_cref& a) {
    using U = typename std::remove_cv<typename std::remove_reference<T>::type>::type;
    static_assert(std::is_constructible<T, const U&>::value, "");
    const U *p = any_cast<U>(&a);
    return p ? static_cast<T>(*p) : throw bad_any_cast();
}

} // namespace stdext
