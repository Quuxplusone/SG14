/*
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#pragma once

#include <type_traits>
#include <utility>
#include <functional>

namespace stdext {

namespace function_ref_detail {

template<typename T> struct wrapper
{
    using type = T;
};

template<typename R, typename... Args> struct vtable
{
    using invoke_ptr_t = R(*)(void*, Args&&...);

    static constexpr invoke_ptr_t empty() noexcept {
        return [](void*, Args&&...) -> R {
            throw std::bad_function_call();
        };
    }

    template<typename C> static constexpr invoke_ptr_t get(wrapper<C>) noexcept {
        return [](void *closure_ptr, Args&&... args)
            noexcept(noexcept(std::declval<C>()(args...))) -> R
        {
            return (*(C*)closure_ptr)( std::forward<Args>(args)... );
        };
    }
};

} // namespace function_ref_detail

template<
    typename Signature
>
class function_ref; // unspecified

template<
    typename R,
    typename... Args
>
class function_ref<R(Args...)>
{
    using vtable_t = function_ref_detail::vtable<R, Args...>;
    using invoke_ptr_t = R(*)(void*, Args&&...);
public:

    function_ref() noexcept :
        invoke_ptr_{vtable_t::empty()}
    {}

    template<
        typename T,
        typename C = std::decay_t<T>,
        typename = std::enable_if_t<
            !(std::is_same<C, function_ref>::value
            || std::is_convertible<C, function_ref>::value
            || (std::is_pointer<C>::value && std::is_function<std::remove_pointer_t<C>>::value))
        >
    >
    function_ref(T&& closure)
    {
#if __cplusplus >= 201703L
        static_assert(std::is_invocable_r<R, std::remove_reference_t<T>, Args...>::value,
            "function_ref cannot be constructed from non-callable type"
        );
#endif
        invoke_ptr_ = vtable_t::get(function_ref_detail::wrapper<std::remove_reference_t<T>>{});
        closure_ptr_ = (void*)std::addressof(closure);
    }

    template<
        typename F,
        typename = std::enable_if_t<
            std::is_function<F>::value
        >
    >
    function_ref(F *closure)
    {
#if __cplusplus >= 201703L
        static_assert(std::is_invocable_r<R, F, Args...>::value,
            "function_ref cannot be constructed from non-callable type"
        );
#endif
        invoke_ptr_ = vtable_t::get(function_ref_detail::wrapper<F>{});
        closure_ptr_ = (void*)closure;
    }

    template<
        typename T
    >
    function_ref(std::reference_wrapper<T> closure)
    {
#if __cplusplus >= 201703L
        static_assert(std::is_invocable_r<R, T, Args...>::value,
            "function_ref cannot be constructed from non-callable type"
        );
#endif
        invoke_ptr_ = vtable_t::get(function_ref_detail::wrapper<T>{});
        closure_ptr_ = (void*)std::addressof(closure.get());
    }

    function_ref(std::nullptr_t) noexcept :
        invoke_ptr_{vtable_t::empty()}
    {}

    function_ref(const function_ref&) = default;
    function_ref(function_ref&&) = default;

    function_ref& operator= (std::nullptr_t) noexcept
    {
        invoke_ptr_ = vtable_t::empty();
        return *this;
    }

    function_ref& operator= (const function_ref&) = default;
    function_ref& operator= (function_ref&&) = default;

    ~function_ref() = default;

    R operator() (Args... args) const
    {
        return invoke_ptr_(
            closure_ptr_,
            std::forward<Args>(args)...
        );
    }

    constexpr bool operator== (std::nullptr_t) const noexcept
    {
        return !operator bool();
    }

    constexpr bool operator!= (std::nullptr_t) const noexcept
    {
        return operator bool();
    }

    explicit constexpr operator bool() const noexcept
    {
        return invoke_ptr_ != vtable_t::empty();
    }

    void swap(function_ref& other) noexcept
    {
        if (this == std::addressof(other)) return;
        std::swap(this->invoke_ptr_, other->invoke_ptr_);
        std::swap(this->closure_ptr_, other->closure_ptr_);
    }

private:
    invoke_ptr_t invoke_ptr_;
    void* closure_ptr_;
};

} // namespace stdext
